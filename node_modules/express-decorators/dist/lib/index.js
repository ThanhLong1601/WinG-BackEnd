"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
require("reflect-metadata");
class Route {
}
exports.Route = Route;
exports.routesKey = Symbol('routesKey');
exports.basePathKey = Symbol('basePathKey');
function getRouteMetadata(target) {
    let routes = Reflect.getMetadata(exports.routesKey, target);
    if (!routes) {
        routes = [];
        Reflect.defineMetadata(exports.routesKey, routes, target);
    }
    return routes;
}
exports.getRouteMetadata = getRouteMetadata;
function route(method, path, middleware = []) {
    return (target, key, descriptor) => {
        const routes = getRouteMetadata(target);
        const handlers = middleware.map(m => getMiddleware(target, m));
        routes.push({
            method,
            path,
            key,
            handlers: [...handlers, descriptor.value]
        });
        return descriptor;
    };
}
exports.route = route;
function basePath(path) {
    return Reflect.metadata(exports.basePathKey, path);
}
exports.basePath = basePath;
function get(path = '*', middleware = []) {
    return route('get', path, middleware);
}
exports.get = get;
function post(path = '*', middleware = []) {
    return route('post', path, middleware);
}
exports.post = post;
function put(path = '*', middleware = []) {
    return route('put', path, middleware);
}
exports.put = put;
function patch(path = '*', middleware = []) {
    return route('patch', path, middleware);
}
exports.patch = patch;
function del(path = '*', middleware = []) {
    return route('del', path, middleware);
}
exports.del = del;
function options(path = '*', middleware = []) {
    return route('options', path, middleware);
}
exports.options = options;
function head(path = '*', middleware = []) {
    return route('head', path, middleware);
}
exports.head = head;
function use(path = '*') {
    return route('use', path);
}
exports.use = use;
function all(path = '*', middleware = []) {
    return route('all', path, middleware);
}
exports.all = all;
function param(param) {
    return (target, key, descriptor) => {
        const routes = getRouteMetadata(target);
        const handler = descriptor.value;
        routes.push({
            method: 'param',
            path: param,
            key,
            handlers: [
                function (request, response, next, value, name) {
                    return Promise.resolve(handler.call(this, request, response, next, value, name)).then(null, next);
                }
            ]
        });
        return descriptor;
    };
}
exports.param = param;
function middleware(fn) {
    return (target, key, descriptor) => {
        const routes = getRouteMetadata(target);
        const middleware = getMiddleware(target, fn);
        routes.push({ method: null, path: null, key, handlers: [middleware] });
        return descriptor;
    };
}
exports.middleware = middleware;
function getMiddleware(target, fn) {
    if (fn instanceof Function) {
        return fn;
    }
    else {
        const middleware = function () {
            const func = this[fn];
            if (!func) {
                throw new Error(`could not find middleware function ${fn} on ${target.constructor.name}`);
            }
            func.apply(this, arguments);
        };
        return middleware;
    }
}
function trimslash(s) {
    return s[s.length - 1] === '/' ? s.slice(0, s.length - 1) : s;
}
function getRoutes(target) {
    let routes = Reflect.getMetadata(exports.routesKey, target) || [];
    const basePath = Reflect.getMetadata(exports.basePathKey, target.constructor);
    if (basePath) {
        routes = routes.map(({ method, path, key, handlers }) => ({
            method,
            path: method === 'param' ? path : trimslash(basePath) + path,
            key,
            handlers
        }));
    }
    const groups = routes.reduce((groups, route) => {
        if (!groups[route.key])
            groups[route.key] = [];
        groups[route.key].push(route);
        return groups;
    }, {});
    routes = [];
    for (const k in groups) {
        const group = groups[k];
        const middleware = group
            .filter(x => x.method === null)
            .map(({ handlers }) => handlers[0]);
        const notMiddleware = group
            .filter(x => x.method !== null)
            .map(({ method, path, key, handlers }) => ({
            method,
            path,
            key,
            handlers: [...middleware, ...handlers].map(h => h.bind(target))
        }));
        [].push.apply(routes, notMiddleware);
    }
    return routes;
}
exports.getRoutes = getRoutes;
function register(router, target) {
    const routes = getRoutes(target);
    for (const route of routes) {
        const handlers = route.method !== 'param'
            ? route.handlers.map((handler) => (request, response, next) => Promise.resolve(handler(request, response, next)).then(null, next))
            : route.handlers;
        const args = [route.path, ...handlers];
        router[route.method].apply(router, args);
    }
}
exports.register = register;
//# sourceMappingURL=index.js.map